// Prisma schema for platform-server persistence
// ConversationState persists per-thread and optional node-specific LLM state

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("AGENTS_DATABASE_URL")
}

model ConversationState {
  id        Int      @id @default(autoincrement())
  threadId  String
  nodeId    String
  state     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([threadId, nodeId])
}
// Local variable overrides (single-user/single-graph model)
model VariableLocal {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Core normalized persistence per spec: threads, runs, messages, run_messages

model Thread {
  id        String   @id @default(uuid()) @db.Uuid
  parentId  String?  @db.Uuid
  parent    Thread?  @relation("ThreadChildren", fields: [parentId], references: [id])
  children  Thread[] @relation("ThreadChildren")
  alias     String   @unique
  createdAt DateTime @default(now())

  runs      Run[]
  containers Container[]

  // Index parentId to accelerate parent-child lookups
  @@index([parentId])
}

enum RunStatus {
  running
  finished
  terminated
}

model Run {
  id         String    @id @default(uuid()) @db.Uuid
  threadId   String    @db.Uuid
  thread     Thread    @relation(fields: [threadId], references: [id], onDelete: Cascade)
  status     RunStatus @default(running)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  runMessages RunMessage[]

  @@index([threadId])
}

enum MessageKind {
  user
  assistant
  system
  tool
}

model Message {
  id        String      @id @default(uuid()) @db.Uuid
  kind      MessageKind
  text      String?
  source    Json
  createdAt DateTime    @default(now())

  runLinks  RunMessage[]
}

enum RunMessageType {
  input
  injected
  output
}

model RunMessage {
  runId     String        @db.Uuid
  messageId String        @db.Uuid
  type      RunMessageType
  createdAt DateTime      @default(now())

  run       Run           @relation(fields: [runId], references: [id], onDelete: Cascade)
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@id([runId, messageId])
  @@index([runId])
}

// Container tracking moved from MongoDB to Postgres via Prisma
// threadId is optional and FK to Thread.id
// Metadata captures labels, platform, ttlSeconds, and termination backoff fields

enum ProviderType {
  docker
}

enum ContainerStatus {
  running
  stopped
  terminating
  failed
}

model Container {
  id                Int             @id @default(autoincrement())
  containerId       String          @unique
  nodeId            String
  threadId          String?         @db.Uuid
  thread            Thread?         @relation(fields: [threadId], references: [id], onDelete: SetNull)
  providerType      ProviderType    @default(docker)
  image             String
  status            ContainerStatus @default(running)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastUsedAt        DateTime
  killAfterAt       DateTime?
  terminationReason String?
  deletedAt         DateTime?
  metadata          Json?

  @@index([status, killAfterAt])
  @@index([nodeId, status, lastUsedAt])
}

// End of schema
// Scheduled reminders persisted for resilience; delivery remains in-memory
model Reminder {
  id        String   @id @default(uuid()) @db.Uuid
  threadId  String
  note      String
  at        DateTime
  createdAt DateTime @default(now())
  completedAt DateTime?

  @@index([threadId])
}
