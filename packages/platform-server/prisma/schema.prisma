// Prisma schema for platform-server persistence
// ConversationState persists per-thread and optional node-specific LLM state

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("AGENTS_DATABASE_URL")
}

model ConversationState {
  id        Int      @id @default(autoincrement())
  threadId  String
  nodeId    String
  state     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([threadId, nodeId])
}

// Local variable overrides (single-user/single-graph model)
model VariableLocal {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LiteLLMVirtualKey {
  id        Int      @id @default(autoincrement())
  alias     String   @unique
  key       String
  expiresAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("litellm_virtual_keys")
}

model UserProfile {
  id        Int      @id @default(1)
  firstName String
  lastName  String
  email     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum MemoryScope {
  global
  perThread
}

enum ContextItemRole {
  system
  user
  assistant
  tool
  memory
  summary
  other
}

model MemoryEntity {
  id        String         @id @default(uuid()) @db.Uuid
  parentId  String?        @db.Uuid @map("parent_id")
  parent    MemoryEntity?  @relation("MemoryEntitiesHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  MemoryEntity[] @relation("MemoryEntitiesHierarchy")
  nodeId    String         @map("node_id")
  threadId  String?        @map("thread_id")
  name      String
  content   String?        @db.Text
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  @@unique([nodeId, threadId, parentId, name], map: "uniq_memory_entity_path")
  @@index([nodeId, threadId, parentId], map: "idx_memory_entity_parent")
  @@map("memory_entities")
}

model ContextItem {
  id          String           @id @default(uuid()) @db.Uuid
  role        ContextItemRole
  contentText String?          @db.Text
  contentJson Json?            @map("content_json")
  metadata    Json?            @default("{}")
  sizeBytes   Int              @map("size_bytes") @default(0)
  createdAt   DateTime         @default(now())

  llmCallContextItems LLMCallContextItem[]

  @@map("context_items")
  @@index([role], map: "idx_context_items_role")
}

// Core normalized persistence per spec: threads, runs, messages, run_messages

model Thread {
  id        String       @id @default(uuid()) @db.Uuid
  parentId  String?      @db.Uuid
  parent    Thread?      @relation("ThreadChildren", fields: [parentId], references: [id])
  children  Thread[]     @relation("ThreadChildren")
  alias     String       @unique
  summary   String?
  status    ThreadStatus @default(open)
  channelNodeId String? @map("channel_node_id") @db.Uuid
  assignedAgentNodeId String? @map("assigned_agent_node_id") @db.Uuid
  // Channel descriptor for replying to origin channel
  channel   Json?
  modelUsed String? @map("model_used")
  createdAt DateTime     @default(now())

  runs       Run[]
  containers Container[]
  runEvents  RunEvent[]

  // Index parentId to accelerate parent-child lookups
  @@index([parentId])
  // Filter by thread status (open/closed)
  @@index([status])
  @@index([assignedAgentNodeId])
}

enum ThreadStatus {
  open
  closed
}

enum RunStatus {
  running
  finished
  terminated
}

model Run {
  id        String    @id @default(uuid()) @db.Uuid
  threadId  String    @db.Uuid
  thread    Thread    @relation(fields: [threadId], references: [id], onDelete: Cascade)
  status    RunStatus @default(running)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  runMessages RunMessage[]
  events      RunEvent[]

  @@index([threadId])
}

enum MessageKind {
  user
  assistant
  system
  tool
}

model Message {
  id        String      @id @default(uuid()) @db.Uuid
  kind      MessageKind
  text      String?
  source    Json
  createdAt DateTime    @default(now())

  runLinks      RunMessage[]
  eventMessages EventMessage[] @relation("MessageEventMessage")
}

enum RunMessageType {
  input
  injected
  output
}

enum RunEventType {
  invocation_message
  injection
  llm_call
  tool_execution
  summarization
}

enum RunEventStatus {
  pending
  running
  success
  error
  cancelled
}

enum LLMCallContextItemDirection {
  input
  output
}

enum EventSourceKind {
  internal
  tracing
}

enum ToolExecStatus {
  success
  error
}

enum ToolOutputSource {
  stdout
  stderr
}

enum ToolOutputStatus {
  success
  error
  timeout
  idle_timeout
  cancelled
  truncated
}

enum AttachmentKind {
  prompt
  response
  tool_input
  tool_output
  provider_raw
  other
}

model RunMessage {
  runId     String         @db.Uuid
  messageId String         @db.Uuid
  type      RunMessageType
  createdAt DateTime       @default(now())

  run     Run     @relation(fields: [runId], references: [id], onDelete: Cascade)
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@id([runId, messageId])
  @@index([runId])
}

model RunEvent {
  id             String          @id @default(uuid()) @db.Uuid
  runId          String          @map("run_id") @db.Uuid
  threadId       String          @map("thread_id") @db.Uuid
  type           RunEventType
  status         RunEventStatus  @default(success)
  ts             DateTime        @default(now())
  startedAt      DateTime?       @map("started_at")
  endedAt        DateTime?       @map("ended_at")
  durationMs     Int?            @map("duration_ms")
  nodeId         String?         @map("node_id")
  sourceKind     EventSourceKind @default(internal) @map("source_kind")
  sourceSpanId   String?         @map("source_span_id")
  schemaVersion  Int             @default(1) @map("schema_version")
  errorCode      String?         @map("error_code")
  errorMessage   String?         @map("error_message")
  metadata       Json            @default("{}")
  idempotencyKey String?         @unique @map("idempotency_key")

  run           Run               @relation(fields: [runId], references: [id], onDelete: Cascade)
  thread        Thread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
  eventMessage  EventMessage?
  llmCall       LLMCall?
  toolExecution ToolExecution?
  summarization Summarization?
  injection     Injection?
  attachments   EventAttachment[]
  outputChunks  ToolOutputChunk[]
  outputTerminal ToolOutputTerminal?

  @@index([runId, ts])
  @@index([runId, ts, id])
  @@index([threadId, ts])
  @@index([sourceKind, sourceSpanId])
  @@map("run_events")
}

model EventMessage {
  eventId   String @id @map("event_id") @db.Uuid
  messageId String @map("message_id") @db.Uuid
  role      String

  event   RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  message Message  @relation("MessageEventMessage", fields: [messageId], references: [id], onDelete: Cascade)

  @@map("event_messages")
}

model LLMCall {
  eventId      String  @id @map("event_id") @db.Uuid
  provider     String?
  model        String?
  temperature  Float?
  topP         Float?  @map("top_p")
  stopReason   String? @map("stop_reason")
  contextItemIds String[] @map("context_item_ids") @default([])
  newContextItemCount Int @map("new_context_item_count") @default(0)
  responseText String? @map("response_text") @db.Text
  rawResponse  Json?   @map("raw_response")
  inputTokens Int? @map("input_tokens")
  cachedInputTokens Int? @map("cached_input_tokens")
  outputTokens Int? @map("output_tokens")
  reasoningTokens Int? @map("reasoning_tokens")
  totalTokens Int? @map("total_tokens")

  event          RunEvent        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  toolCalls      ToolCall[]
  toolExecutions ToolExecution[] @relation("LLMCallToolExecutions")
  contextItems   LLMCallContextItem[]

  @@map("llm_calls")
}

model LLMCallContextItem {
  id             String                         @id @default(uuid()) @db.Uuid
  llmCallEventId String                         @map("llm_call_event_id") @db.Uuid
  contextItemId  String                         @map("context_item_id") @db.Uuid
  idx            Int
  direction      LLMCallContextItemDirection
  isNew          Boolean                        @map("is_new") @default(false)
  createdAt      DateTime                       @map("created_at") @default(now())

  llmCall     LLMCall     @relation(fields: [llmCallEventId], references: [eventId], onDelete: Cascade)
  contextItem ContextItem @relation(fields: [contextItemId], references: [id], onDelete: Cascade)

  @@unique([llmCallEventId, idx])
  @@index([llmCallEventId])
  @@index([contextItemId])
  @@map("llm_call_context_items")
}

model ToolCall {
  id             String @id @default(uuid()) @db.Uuid
  llmCallEventId String @map("llm_call_event_id") @db.Uuid
  callId         String @map("call_id")
  name           String
  arguments      Json
  idx            Int

  llmCall LLMCall @relation(fields: [llmCallEventId], references: [eventId], onDelete: Cascade)

  @@unique([llmCallEventId, callId])
  @@index([llmCallEventId, idx])
  @@map("tool_calls")
}

model ToolExecution {
  eventId        String         @id @map("event_id") @db.Uuid
  llmCallEventId String?        @map("llm_call_event_id") @db.Uuid
  toolName       String         @map("tool_name")
  toolCallId     String?        @map("tool_call_id")
  input          Json
  output         Json?
  execStatus     ToolExecStatus @map("exec_status")
  errorMessage   String?        @map("error_message")
  raw            Json?

  event   RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  llmCall LLMCall? @relation("LLMCallToolExecutions", fields: [llmCallEventId], references: [eventId], onDelete: SetNull)

  @@index([llmCallEventId])
  @@index([toolName])
  @@map("tool_executions")
}

model Summarization {
  eventId          String @id @map("event_id") @db.Uuid
  oldContextTokens Int?   @map("old_context_tokens")
  summaryText      String @map("summary_text") @db.Text
  newContextCount  Int    @map("new_context_count")
  raw              Json?

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("summarizations")
}

model Injection {
  eventId    String   @id @map("event_id") @db.Uuid
  messageIds String[] @map("message_ids") @db.Uuid
  reason     String?

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("injections")
}

model EventAttachment {
  id          String         @id @default(uuid()) @db.Uuid
  eventId     String         @map("event_id") @db.Uuid
  kind        AttachmentKind
  contentJson Json?          @map("content_json")
  contentText String?        @map("content_text") @db.Text
  isGzip      Boolean        @default(false) @map("is_gzip")
  sizeBytes   Int            @default(0) @map("size_bytes")

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@map("event_attachments")
}

model ToolOutputChunk {
  id        String            @id @default(uuid()) @db.Uuid
  eventId   String            @map("event_id") @db.Uuid
  seqGlobal Int               @map("seq_global")
  seqStream Int               @map("seq_stream")
  source    ToolOutputSource
  data      String            @db.Text
  ts        DateTime
  bytes     Int               @default(0)
  createdAt DateTime          @default(now()) @map("created_at")

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, seqGlobal])
  @@index([eventId, seqGlobal])
  @@index([eventId, source, seqStream])
  @@map("tool_output_chunks")
}

model ToolOutputTerminal {
  eventId       String            @id @map("event_id") @db.Uuid
  exitCode      Int?              @map("exit_code")
  status        ToolOutputStatus
  bytesStdout   Int               @default(0) @map("bytes_stdout")
  bytesStderr   Int               @default(0) @map("bytes_stderr")
  totalChunks   Int               @default(0) @map("total_chunks")
  droppedChunks Int               @default(0) @map("dropped_chunks")
  savedPath     String?           @map("saved_path")
  message       String?           @db.Text
  ts            DateTime          @default(now())
  createdAt     DateTime          @default(now()) @map("created_at")

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("tool_output_terminals")
}

// Container tracking moved from MongoDB to Postgres via Prisma
// threadId is optional and FK to Thread.id
// Metadata captures labels, platform, ttlSeconds, and termination backoff fields

enum ProviderType {
  docker
}

enum ContainerStatus {
  running
  stopped
  terminating
  failed
}

enum ContainerEventType {
  oom
  die
  kill
}

model Container {
  id                Int             @id @default(autoincrement())
  containerId       String          @unique
  dockerContainerId String          @unique
  nodeId            String
  threadId          String?         @db.Uuid
  thread            Thread?         @relation(fields: [threadId], references: [id], onDelete: SetNull)
  providerType      ProviderType    @default(docker)
  image             String
  name              String
  status            ContainerStatus @default(running)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastUsedAt        DateTime
  killAfterAt       DateTime?
  terminationReason String?
  deletedAt         DateTime?
  metadata          Json?

  events ContainerEvent[]

  @@index([status, killAfterAt])
  @@index([nodeId, status, lastUsedAt])
}

model ContainerEvent {
  id                Int                 @id @default(autoincrement())
  containerDbId     Int
  container         Container           @relation(fields: [containerDbId], references: [id], onDelete: Cascade)
  eventType         ContainerEventType
  exitCode          Int?
  signal            String?
  reason            String?
  message           String?
  createdAt         DateTime            @default(now())

  @@index([containerDbId, createdAt])
}

// End of schema
// Scheduled reminders persisted for resilience; delivery remains in-memory
model Reminder {
  id          String    @id @default(uuid()) @db.Uuid
  threadId    String    @db.Uuid
  note        String
  at          DateTime
  createdAt   DateTime  @default(now())
  completedAt DateTime?
  cancelledAt DateTime?

  @@index([threadId])
}
