// Prisma schema for platform-server persistence
// ConversationState persists per-thread and optional node-specific LLM state

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("AGENTS_DATABASE_URL")
}

model ConversationState {
  id        Int      @id @default(autoincrement())
  threadId  String
  nodeId    String
  state     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([threadId, nodeId])
}

// Local variable overrides (single-user/single-graph model)
model VariableLocal {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum MemoryScope {
  global
  perThread
}

enum ContextItemRole {
  system
  user
  assistant
  tool
  memory
  summary
  other
}

model Memory {
  id        String      @id @default(uuid()) @db.Uuid
  nodeId    String      @map("node_id")
  scope     MemoryScope
  threadId  String?     @map("thread_id")
  data      Json        @default("{}")
  dirs      Json        @default("{}")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  @@index([nodeId, scope], map: "idx_memories_lookup")
  @@map("memories")
}

model ContextItem {
  id          String           @id @default(uuid()) @db.Uuid
  role        ContextItemRole
  contentText String?          @db.Text
  contentJson Json?            @map("content_json")
  metadata    Json?            @default("{}")
  sizeBytes   Int              @map("size_bytes") @default(0)
  createdAt   DateTime         @default(now())

  @@map("context_items")
  @@index([role], map: "idx_context_items_role")
}

// Core normalized persistence per spec: threads, runs, messages, run_messages

model Thread {
  id        String       @id @default(uuid()) @db.Uuid
  parentId  String?      @db.Uuid
  parent    Thread?      @relation("ThreadChildren", fields: [parentId], references: [id])
  children  Thread[]     @relation("ThreadChildren")
  alias     String       @unique
  summary   String?
  status    ThreadStatus @default(open)
  // Channel descriptor for replying to origin channel
  channel   Json?
  createdAt DateTime     @default(now())

  runs       Run[]
  containers Container[]
  runEvents  RunEvent[]

  // Index parentId to accelerate parent-child lookups
  @@index([parentId])
  // Filter by thread status (open/closed)
  @@index([status])
}

enum ThreadStatus {
  open
  closed
}

enum RunStatus {
  running
  finished
  terminated
}

model Run {
  id        String    @id @default(uuid()) @db.Uuid
  threadId  String    @db.Uuid
  thread    Thread    @relation(fields: [threadId], references: [id], onDelete: Cascade)
  status    RunStatus @default(running)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  runMessages RunMessage[]
  events      RunEvent[]

  @@index([threadId])
}

enum MessageKind {
  user
  assistant
  system
  tool
}

model Message {
  id        String      @id @default(uuid()) @db.Uuid
  kind      MessageKind
  text      String?
  source    Json
  createdAt DateTime    @default(now())

  runLinks      RunMessage[]
  eventMessages EventMessage[] @relation("MessageEventMessage")
}

enum RunMessageType {
  input
  injected
  output
}

enum RunEventType {
  invocation_message
  injection
  llm_call
  tool_execution
  summarization
}

enum RunEventStatus {
  pending
  running
  success
  error
  cancelled
}

enum EventSourceKind {
  internal
  tracing
}

enum ToolExecStatus {
  success
  error
}

enum AttachmentKind {
  prompt
  response
  tool_input
  tool_output
  provider_raw
  other
}

model RunMessage {
  runId     String         @db.Uuid
  messageId String         @db.Uuid
  type      RunMessageType
  createdAt DateTime       @default(now())

  run     Run     @relation(fields: [runId], references: [id], onDelete: Cascade)
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@id([runId, messageId])
  @@index([runId])
}

model RunEvent {
  id             String          @id @default(uuid()) @db.Uuid
  runId          String          @map("run_id") @db.Uuid
  threadId       String          @map("thread_id") @db.Uuid
  type           RunEventType
  status         RunEventStatus  @default(success)
  ts             DateTime        @default(now())
  startedAt      DateTime?       @map("started_at")
  endedAt        DateTime?       @map("ended_at")
  durationMs     Int?            @map("duration_ms")
  nodeId         String?         @map("node_id")
  sourceKind     EventSourceKind @default(internal) @map("source_kind")
  sourceSpanId   String?         @map("source_span_id")
  schemaVersion  Int             @default(1) @map("schema_version")
  errorCode      String?         @map("error_code")
  errorMessage   String?         @map("error_message")
  metadata       Json            @default("{}")
  idempotencyKey String?         @unique @map("idempotency_key")

  run           Run               @relation(fields: [runId], references: [id], onDelete: Cascade)
  thread        Thread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
  eventMessage  EventMessage?
  llmCall       LLMCall?
  toolExecution ToolExecution?
  summarization Summarization?
  injection     Injection?
  attachments   EventAttachment[]

  @@index([runId, ts])
  @@index([runId, ts, id])
  @@index([threadId, ts])
  @@index([sourceKind, sourceSpanId])
  @@map("run_events")
}

model EventMessage {
  eventId   String @id @map("event_id") @db.Uuid
  messageId String @map("message_id") @db.Uuid
  role      String

  event   RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  message Message  @relation("MessageEventMessage", fields: [messageId], references: [id], onDelete: Cascade)

  @@map("event_messages")
}

model LLMCall {
  eventId      String  @id @map("event_id") @db.Uuid
  provider     String?
  model        String?
  temperature  Float?
  topP         Float?  @map("top_p")
  stopReason   String? @map("stop_reason")
  contextItemIds String[] @map("context_item_ids") @default([])
  responseText String? @map("response_text") @db.Text
  rawResponse  Json?   @map("raw_response")
  inputTokens Int? @map("input_tokens")
  cachedInputTokens Int? @map("cached_input_tokens")
  outputTokens Int? @map("output_tokens")
  reasoningTokens Int? @map("reasoning_tokens")
  totalTokens Int? @map("total_tokens")

  event          RunEvent        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  toolCalls      ToolCall[]
  toolExecutions ToolExecution[] @relation("LLMCallToolExecutions")

  @@map("llm_calls")
}

model ToolCall {
  id             String @id @default(uuid()) @db.Uuid
  llmCallEventId String @map("llm_call_event_id") @db.Uuid
  callId         String @map("call_id")
  name           String
  arguments      Json
  idx            Int

  llmCall LLMCall @relation(fields: [llmCallEventId], references: [eventId], onDelete: Cascade)

  @@unique([llmCallEventId, callId])
  @@index([llmCallEventId, idx])
  @@map("tool_calls")
}

model ToolExecution {
  eventId        String         @id @map("event_id") @db.Uuid
  llmCallEventId String?        @map("llm_call_event_id") @db.Uuid
  toolName       String         @map("tool_name")
  toolCallId     String?        @map("tool_call_id")
  input          Json
  output         Json?
  execStatus     ToolExecStatus @map("exec_status")
  errorMessage   String?        @map("error_message")
  raw            Json?

  event   RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  llmCall LLMCall? @relation("LLMCallToolExecutions", fields: [llmCallEventId], references: [eventId], onDelete: SetNull)

  @@index([llmCallEventId])
  @@index([toolName])
  @@map("tool_executions")
}

model Summarization {
  eventId          String @id @map("event_id") @db.Uuid
  oldContextTokens Int?   @map("old_context_tokens")
  summaryText      String @map("summary_text") @db.Text
  newContextCount  Int    @map("new_context_count")
  raw              Json?

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("summarizations")
}

model Injection {
  eventId    String   @id @map("event_id") @db.Uuid
  messageIds String[] @map("message_ids") @db.Uuid
  reason     String?

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("injections")
}

model EventAttachment {
  id          String         @id @default(uuid()) @db.Uuid
  eventId     String         @map("event_id") @db.Uuid
  kind        AttachmentKind
  contentJson Json?          @map("content_json")
  contentText String?        @map("content_text") @db.Text
  isGzip      Boolean        @default(false) @map("is_gzip")
  sizeBytes   Int            @default(0) @map("size_bytes")

  event RunEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@map("event_attachments")
}

// Container tracking moved from MongoDB to Postgres via Prisma
// threadId is optional and FK to Thread.id
// Metadata captures labels, platform, ttlSeconds, and termination backoff fields

enum ProviderType {
  docker
}

enum ContainerStatus {
  running
  stopped
  terminating
  failed
}

model Container {
  id                Int             @id @default(autoincrement())
  containerId       String          @unique
  nodeId            String
  threadId          String?         @db.Uuid
  thread            Thread?         @relation(fields: [threadId], references: [id], onDelete: SetNull)
  providerType      ProviderType    @default(docker)
  image             String
  status            ContainerStatus @default(running)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  lastUsedAt        DateTime
  killAfterAt       DateTime?
  terminationReason String?
  deletedAt         DateTime?
  metadata          Json?

  @@index([status, killAfterAt])
  @@index([nodeId, status, lastUsedAt])
}

// End of schema
// Scheduled reminders persisted for resilience; delivery remains in-memory
model Reminder {
  id          String    @id @default(uuid()) @db.Uuid
  threadId    String    @db.Uuid
  note        String
  at          DateTime
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([threadId])
}
